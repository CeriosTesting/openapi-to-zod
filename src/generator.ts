import { readFileSync, writeFileSync } from "node:fs";
import { parse } from "yaml";
import { generateEnum } from "./generators/enum-generator";
import { generateJSDoc } from "./generators/jsdoc-generator";
import { PropertyGenerator } from "./generators/property-generator";
import type { GeneratorOptions, OpenAPISchema, OpenAPISpec } from "./types";
import { resolveRef, toCamelCase } from "./utils/name-utils";

export class ZodSchemaGenerator {
	private schemas: Map<string, string> = new Map();
	private enums: Map<string, string> = new Map();
	private schemaDependencies: Map<string, Set<string>> = new Map();
	private options: GeneratorOptions;
	private spec: OpenAPISpec;
	private propertyGenerator: PropertyGenerator;

	constructor(options: GeneratorOptions) {
		this.options = {
			mode: options.mode || "normal",
			input: options.input,
			output: options.output,
			includeDescriptions: options.includeDescriptions ?? true,
			enumType: options.enumType || "zod",
			useDescribe: options.useDescribe ?? false,
			schemaType: options.schemaType || "all",
			prefix: options.prefix,
			suffix: options.suffix,
			showStats: options.showStats ?? true,
		};

		try {
			const yamlContent = readFileSync(this.options.input, "utf-8");
			this.spec = parse(yamlContent);
		} catch (error) {
			if (error instanceof Error) {
				throw new Error(`Failed to parse OpenAPI YAML file at ${this.options.input}:\n${error.message}`);
			}
			throw error;
		}

		this.validateSpec();

		// Initialize property generator with context
		this.propertyGenerator = new PropertyGenerator({
			spec: this.spec,
			schemaDependencies: this.schemaDependencies,
			schemaType: this.options.schemaType || "all",
			mode: this.options.mode || "normal",
			includeDescriptions: this.options.includeDescriptions ?? true,
			useDescribe: this.options.useDescribe ?? false,
			namingOptions: {
				prefix: this.options.prefix,
				suffix: this.options.suffix,
			},
		});
	}

	/**
	 * Generate the complete output file
	 */
	public generate(): void {
		if (!this.spec.components?.schemas) {
			throw new Error("No schemas found in OpenAPI spec");
		}

		// First pass: generate enums
		for (const [name, schema] of Object.entries(this.spec.components.schemas)) {
			if (schema.enum) {
				const { enumCode } = generateEnum(name, schema.enum, {
					enumType: this.options.enumType || "zod",
					prefix: this.options.prefix,
					suffix: this.options.suffix,
				});
				if (enumCode) {
					this.enums.set(name, enumCode);
				}
			}
		}

		// Second pass: generate schemas and track dependencies
		for (const [name, schema] of Object.entries(this.spec.components.schemas)) {
			this.generateComponentSchema(name, schema);
		}

		// Sort schemas by dependencies
		const orderedSchemaNames = this.topologicalSort();

		// Build output
		const output: string[] = ["// Auto-generated by @cerios/zod-openapi", "// Do not edit this file manually", ""];

		// Add statistics if enabled (must be explicitly true)
		if (this.options.showStats === true) {
			output.push(...this.generateStats());
			output.push("");
		}

		output.push('import { z } from "zod";');
		output.push("");

		// Add enums
		if (this.enums.size > 0) {
			output.push("// Enums");
			for (const enumCode of this.enums.values()) {
				output.push(enumCode);
				output.push("");
			}
		}

		// Add schemas with types in dependency order
		output.push("// Schemas");
		for (const name of orderedSchemaNames) {
			const schemaCode = this.schemas.get(name);
			if (schemaCode) {
				output.push(schemaCode);

				// Add type immediately after schema (if not already included)
				if (!schemaCode.includes(`export type ${name}`)) {
					const schemaName = `${toCamelCase(name, { prefix: this.options.prefix, suffix: this.options.suffix })}Schema`;
					output.push(`export type ${name} = z.infer<typeof ${schemaName}>;`);
				}

				output.push("");
			}
		}

		// Write to file
		writeFileSync(this.options.output, output.join("\n"));
	}

	/**
	 * Validate the OpenAPI specification
	 */
	// biome-ignore lint/correctness/noUnusedPrivateClassMembers: Called in constructor on line 36
	private validateSpec(): void {
		if (!this.spec.components?.schemas) {
			throw new Error(
				`No schemas found in OpenAPI spec at ${this.options.input}. Expected to find schemas at components.schemas`
			);
		}

		// Validate all $refs can be resolved
		const allSchemas = Object.keys(this.spec.components.schemas);
		for (const [name, schema] of Object.entries(this.spec.components.schemas)) {
			try {
				this.validateSchemaRefs(name, schema, allSchemas);
			} catch (error) {
				if (error instanceof Error) {
					throw new Error(`Invalid schema '${name}': ${error.message}`);
				}
				throw error;
			}
		}
	}

	/**
	 * Validate all $ref references in a schema
	 */
	private validateSchemaRefs(schemaName: string, schema: OpenAPISchema, allSchemas: string[], path = ""): void {
		if (schema.$ref) {
			const refName = resolveRef(schema.$ref);
			if (!allSchemas.includes(refName)) {
				throw new Error(
					`Invalid reference${path ? ` at '${path}'` : ""}: ` +
						`'${schema.$ref}' points to non-existent schema '${refName}'`
				);
			}
		}

		// Recursively validate nested schemas
		if (schema.properties) {
			for (const [propName, propSchema] of Object.entries(schema.properties)) {
				this.validateSchemaRefs(schemaName, propSchema, allSchemas, path ? `${path}.${propName}` : propName);
			}
		}

		if (schema.items) {
			this.validateSchemaRefs(schemaName, schema.items, allSchemas, `${path}[]`);
		}

		if (schema.prefixItems) {
			schema.prefixItems.forEach((s, i) => {
				this.validateSchemaRefs(schemaName, s, allSchemas, `${path}.prefixItems[${i}]`);
			});
		}

		if (schema.allOf) {
			schema.allOf.forEach((s, i) => {
				this.validateSchemaRefs(schemaName, s, allSchemas, `${path}.allOf[${i}]`);
			});
		}

		if (schema.oneOf) {
			schema.oneOf.forEach((s, i) => {
				this.validateSchemaRefs(schemaName, s, allSchemas, `${path}.oneOf[${i}]`);
			});
		}

		if (schema.anyOf) {
			schema.anyOf.forEach((s, i) => {
				this.validateSchemaRefs(schemaName, s, allSchemas, `${path}.anyOf[${i}]`);
			});
		}
	}

	/**
	 * Generate schema for a component
	 */
	private generateComponentSchema(name: string, schema: OpenAPISchema): void {
		// Initialize dependencies for this schema
		if (!this.schemaDependencies.has(name)) {
			this.schemaDependencies.set(name, new Set());
		}

		// Handle enums at the top level
		if (schema.enum) {
			const jsdoc = generateJSDoc(schema, name, { includeDescriptions: this.options.includeDescriptions ?? true });
			const { enumCode, schemaCode, typeCode } = generateEnum(name, schema.enum, {
				enumType: this.options.enumType || "zod",
				prefix: this.options.prefix,
				suffix: this.options.suffix,
			});

			if (enumCode) {
				this.enums.set(name, enumCode);
			}

			const enumSchemaCode = `${jsdoc}${schemaCode}\n${typeCode}`;
			this.schemas.set(name, enumSchemaCode);
			return;
		}

		const schemaName = `${toCamelCase(name, { prefix: this.options.prefix, suffix: this.options.suffix })}Schema`;
		const jsdoc = generateJSDoc(schema, name, { includeDescriptions: this.options.includeDescriptions ?? true });

		// For allOf with single $ref, track dependency manually since we simplify it
		if (schema.allOf && schema.allOf.length === 1 && schema.allOf[0].$ref) {
			const refName = resolveRef(schema.allOf[0].$ref);
			if (!this.schemaDependencies.has(name)) {
				this.schemaDependencies.set(name, new Set());
			}
			this.schemaDependencies.get(name)?.add(refName);
		}

		// Check if this is just a simple $ref (alias)
		const isAlias = !!(schema.$ref && !schema.properties && !schema.allOf && !schema.oneOf && !schema.anyOf);
		const zodSchema = this.propertyGenerator.generatePropertySchema(schema, name, isAlias);
		const zodSchemaCode = `${jsdoc}export const ${schemaName} = ${zodSchema};`;

		this.schemas.set(name, zodSchemaCode);
	}

	/**
	 * Topological sort for schema dependencies
	 * Returns schemas in the order they should be declared
	 */
	private topologicalSort(): string[] {
		const sorted: string[] = [];
		const visited = new Set<string>();
		const visiting = new Set<string>();
		const aliases: string[] = [];

		// Performance optimization: Cache schema code lookups
		const schemaCodeCache = new Map<string, string>();
		for (const [name, code] of this.schemas) {
			schemaCodeCache.set(name, code);
		}

		const visit = (name: string): void => {
			if (visited.has(name)) return;

			// Detect circular dependencies
			if (visiting.has(name)) {
				// For circular deps, we'll just continue - Zod can handle forward references in many cases
				return;
			}

			visiting.add(name);

			// Check if this is a simple alias (just assigns another schema directly)
			const schemaCode = schemaCodeCache.get(name) || "";
			const isSimpleAlias =
				schemaCode.match(/= (\w+Schema);$/) !== null &&
				!schemaCode.includes("z.object") &&
				!schemaCode.includes("z.enum") &&
				!schemaCode.includes("z.union") &&
				!schemaCode.includes("z.array") &&
				!schemaCode.includes(".and(");

			if (isSimpleAlias) {
				// For simple aliases, just mark as visited and add to aliases list
				visiting.delete(name);
				visited.add(name);
				aliases.push(name);
				return;
			}

			// Visit dependencies first for non-alias schemas
			const deps = this.schemaDependencies.get(name);
			if (deps && deps.size > 0) {
				for (const dep of deps) {
					if (this.schemas.has(dep)) {
						visit(dep);
					}
				}
			}

			visiting.delete(name);
			visited.add(name);
			sorted.push(name);
		};

		// Visit all schemas
		for (const name of this.schemas.keys()) {
			visit(name);
		}

		// Add aliases at the end
		return [...sorted, ...aliases];
	}

	/**
	 * Generate statistics about the generated schemas
	 */
	private generateStats(): string[] {
		const stats = {
			totalSchemas: this.schemas.size,
			enums: this.enums.size,
			withCircularRefs: 0,
			withDiscriminators: 0,
			withConstraints: 0,
		};

		// Count schemas with special features
		for (const code of this.schemas.values()) {
			if (code.includes("z.lazy(")) stats.withCircularRefs++;
			if (code.includes("z.discriminatedUnion")) stats.withDiscriminators++;
			if (code.includes(".min(") || code.includes(".max(") || code.includes(".gte(")) {
				stats.withConstraints++;
			}
		}

		return [
			"// Generation Statistics:",
			`//   Total schemas: ${stats.totalSchemas}`,
			`//   Enums: ${stats.enums}`,
			`//   Circular references: ${stats.withCircularRefs}`,
			`//   Discriminated unions: ${stats.withDiscriminators}`,
			`//   With constraints: ${stats.withConstraints}`,
			`//   Generated at: ${new Date().toISOString()}`,
		];
	}
}
